<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Jg_types (jingoo.Jingoo.Jg_types)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">jingoo</a> &#x00BB; <a href="../index.html">Jingoo</a> &#x00BB; Jg_types</nav><header class="odoc-preamble"><h1>Module <code><span>Jingoo.Jg_types</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#boxing-ocaml-values">Boxing OCaml values</a></li><li><a href="#unboxing-ocaml-values">Unboxing OCaml values</a></li><li><a href="#helpers-for-function-writing">Helpers for function writing</a></li><li><a href="#notes-tvalue">Notes about some data types</a></li><li><a href="#function-calls">Function calls</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec exception anchored" id="exception-SyntaxError"><a href="#exception-SyntaxError" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">SyntaxError</span> <span class="keyword">of</span> string</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-environment"><a href="#type-environment" class="anchor"></a><code><span><span class="keyword">type</span> environment</span><span> = </span><span>{</span></code><ol><li id="type-environment.autoescape" class="def record field anchored"><a href="#type-environment.autoescape" class="anchor"></a><code><span>autoescape : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If true, template variables are auto escaped when output.</p><span class="comment-delim">*)</span></div></li><li id="type-environment.strict_mode" class="def record field anchored"><a href="#type-environment.strict_mode" class="anchor"></a><code><span>strict_mode : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If true, strict type cheking is enabled. If false, some kind of invalid type usages are just ignored. for example, following expression throws exception if <code>strict_mode = true</code>, but is skipped if <code>strict_mode = false</code>.</p><pre class="language-ocaml"><code>{# 3(Tint) is not iterable #}
{% for item in 3 %}
  {{ item }}
{% endfor %}</code></pre><span class="comment-delim">*)</span></div></li><li id="type-environment.template_dirs" class="def record field anchored"><a href="#type-environment.template_dirs" class="anchor"></a><code><span>template_dirs : <span>string list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Template search path list used by <code>{% include %}</code> statements. Jingoo will always search in current directory in last resort.</p><span class="comment-delim">*)</span></div></li><li id="type-environment.filters" class="def record field anchored"><a href="#type-environment.filters" class="anchor"></a><code><span>filters : <span><span>(string * <a href="#type-tvalue">tvalue</a>)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>User-defined filters.</p><span class="comment-delim">*)</span></div></li><li id="type-environment.extensions" class="def record field anchored"><a href="#type-environment.extensions" class="anchor"></a><code><span>extensions : <span>string list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Path list of shared library modules (<code>.cms</code> or <code>.cmxs</code> files) which are dynamically loaded.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>See <code>std_env</code></p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-context"><a href="#type-context" class="anchor"></a><code><span><span class="keyword">and</span> context</span><span> = </span><span>{</span></code><ol><li id="type-context.frame_stack" class="def record field anchored"><a href="#type-context.frame_stack" class="anchor"></a><code><span>frame_stack : <span><a href="#type-frame">frame</a> list</span>;</span></code></li><li id="type-context.macro_table" class="def record field anchored"><a href="#type-context.macro_table" class="anchor"></a><code><span>macro_table : <span><span>(string, <a href="#type-macro">macro</a>)</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span>;</span></code></li><li id="type-context.namespace_table" class="def record field anchored"><a href="#type-context.namespace_table" class="anchor"></a><code><span>namespace_table : <span><span>(string, <span><span>(string, <a href="#type-tvalue">tvalue</a>)</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span>)</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span>;</span></code></li><li id="type-context.active_filters" class="def record field anchored"><a href="#type-context.active_filters" class="anchor"></a><code><span>active_filters : <span>string list</span>;</span></code></li><li id="type-context.serialize" class="def record field anchored"><a href="#type-context.serialize" class="anchor"></a><code><span>serialize : bool;</span></code></li><li id="type-context.output" class="def record field anchored"><a href="#type-context.output" class="anchor"></a><code><span>output : <span><a href="#type-tvalue">tvalue</a> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-frame"><a href="#type-frame" class="anchor"></a><code><span><span class="keyword">and</span> frame</span><span> = <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-tvalue">tvalue</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-macro"><a href="#type-macro" class="anchor"></a><code><span><span class="keyword">and</span> macro</span><span> = </span></code><ol><li id="type-macro.Macro" class="def variant constructor anchored"><a href="#type-macro.Macro" class="anchor"></a><code><span>| </span><span><span class="constructor">Macro</span> <span class="keyword">of</span> <a href="#type-macro_arg_names">macro_arg_names</a> * <a href="#type-macro_defaults">macro_defaults</a> * <a href="#type-macro_code">macro_code</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-macro_arg_names"><a href="#type-macro_arg_names" class="anchor"></a><code><span><span class="keyword">and</span> macro_arg_names</span><span> = <span>string list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-macro_defaults"><a href="#type-macro_defaults" class="anchor"></a><code><span><span class="keyword">and</span> macro_defaults</span><span> = <a href="#type-kwargs">kwargs</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-macro_code"><a href="#type-macro_code" class="anchor"></a><code><span><span class="keyword">and</span> macro_code</span><span> = <span><a href="#type-statement">statement</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tvalue"><a href="#type-tvalue" class="anchor"></a><code><span><span class="keyword">and</span> tvalue</span><span> = </span></code><ol><li id="type-tvalue.Tnull" class="def variant constructor anchored"><a href="#type-tvalue.Tnull" class="anchor"></a><code><span>| </span><span><span class="constructor">Tnull</span></span></code></li><li id="type-tvalue.Tint" class="def variant constructor anchored"><a href="#type-tvalue.Tint" class="anchor"></a><code><span>| </span><span><span class="constructor">Tint</span> <span class="keyword">of</span> int</span></code></li><li id="type-tvalue.Tbool" class="def variant constructor anchored"><a href="#type-tvalue.Tbool" class="anchor"></a><code><span>| </span><span><span class="constructor">Tbool</span> <span class="keyword">of</span> bool</span></code></li><li id="type-tvalue.Tfloat" class="def variant constructor anchored"><a href="#type-tvalue.Tfloat" class="anchor"></a><code><span>| </span><span><span class="constructor">Tfloat</span> <span class="keyword">of</span> float</span></code></li><li id="type-tvalue.Tstr" class="def variant constructor anchored"><a href="#type-tvalue.Tstr" class="anchor"></a><code><span>| </span><span><span class="constructor">Tstr</span> <span class="keyword">of</span> string</span></code></li><li id="type-tvalue.Tobj" class="def variant constructor anchored"><a href="#type-tvalue.Tobj" class="anchor"></a><code><span>| </span><span><span class="constructor">Tobj</span> <span class="keyword">of</span> <span><span>(string * <a href="#type-tvalue">tvalue</a>)</span> list</span></span></code></li><li id="type-tvalue.Thash" class="def variant constructor anchored"><a href="#type-tvalue.Thash" class="anchor"></a><code><span>| </span><span><span class="constructor">Thash</span> <span class="keyword">of</span> <span><span>(string, <a href="#type-tvalue">tvalue</a>)</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span></span></code></li><li id="type-tvalue.Tpat" class="def variant constructor anchored"><a href="#type-tvalue.Tpat" class="anchor"></a><code><span>| </span><span><span class="constructor">Tpat</span> <span class="keyword">of</span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-tvalue">tvalue</a></span></code></li><li id="type-tvalue.Tlist" class="def variant constructor anchored"><a href="#type-tvalue.Tlist" class="anchor"></a><code><span>| </span><span><span class="constructor">Tlist</span> <span class="keyword">of</span> <span><a href="#type-tvalue">tvalue</a> list</span></span></code></li><li id="type-tvalue.Tset" class="def variant constructor anchored"><a href="#type-tvalue.Tset" class="anchor"></a><code><span>| </span><span><span class="constructor">Tset</span> <span class="keyword">of</span> <span><a href="#type-tvalue">tvalue</a> list</span></span></code></li><li id="type-tvalue.Tfun" class="def variant constructor anchored"><a href="#type-tvalue.Tfun" class="anchor"></a><code><span>| </span><span><span class="constructor">Tfun</span> <span class="keyword">of</span> <span><span class="optlabel">?kwargs</span>:<a href="#type-kwargs">kwargs</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tvalue">tvalue</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-tvalue">tvalue</a></span></code></li><li id="type-tvalue.Tarray" class="def variant constructor anchored"><a href="#type-tvalue.Tarray" class="anchor"></a><code><span>| </span><span><span class="constructor">Tarray</span> <span class="keyword">of</span> <span><a href="#type-tvalue">tvalue</a> array</span></span></code></li><li id="type-tvalue.Tlazy" class="def variant constructor anchored"><a href="#type-tvalue.Tlazy" class="anchor"></a><code><span>| </span><span><span class="constructor">Tlazy</span> <span class="keyword">of</span> <span><a href="#type-tvalue">tvalue</a> <span class="xref-unresolved">Stdlib</span>.Lazy.t</span></span></code></li><li id="type-tvalue.Tvolatile" class="def variant constructor anchored"><a href="#type-tvalue.Tvolatile" class="anchor"></a><code><span>| </span><span><span class="constructor">Tvolatile</span> <span class="keyword">of</span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-tvalue">tvalue</a></span></code></li><li id="type-tvalue.Tsafe" class="def variant constructor anchored"><a href="#type-tvalue.Tsafe" class="anchor"></a><code><span>| </span><span><span class="constructor">Tsafe</span> <span class="keyword">of</span> string</span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-kwargs"><a href="#type-kwargs" class="anchor"></a><code><span><span class="keyword">and</span> kwargs</span><span> = <span><span>(string * <a href="#type-tvalue">tvalue</a>)</span> list</span></span></code></div></div><h3 id="boxing-ocaml-values"><a href="#boxing-ocaml-values" class="anchor"></a>Boxing OCaml values</h3><h3 id="unboxing-ocaml-values"><a href="#unboxing-ocaml-values" class="anchor"></a>Unboxing OCaml values</h3><p>Unboxing operations raise <code>Invalid_argument</code> in case of type error.</p><h3 id="helpers-for-function-writing"><a href="#helpers-for-function-writing" class="anchor"></a>Helpers for function writing</h3><h3 id="notes-tvalue"><a href="#notes-tvalue" class="anchor"></a>Notes about some data types</h3><p><a href="#type-tvalue.Tobj"><code>tvalue.Tobj</code></a> Key/value object using an associative list.</p><p><a href="#type-tvalue.Thash"><code>tvalue.Thash</code></a> Key/value objects using a hash table.</p><p><a href="#type-tvalue.Tpat"><code>tvalue.Tpat</code></a> Key/value object using a function to map <code>&quot;key&quot;</code> to <code>value</code>. Faster than <a href="#type-tvalue.Tobj"><code>tvalue.Tobj</code></a> and <a href="#type-tvalue.Thash"><code>tvalue.Thash</code></a>, but not iterable nor testable.</p><p><a href="#type-tvalue.Tset"><code>tvalue.Tset</code></a> Tuples</p><p><a href="#type-tvalue.Tlazy"><code>tvalue.Tlazy</code></a> Lazy values are actually computed only when needed. Useful for recursive some data structure. In the following example, your app would throw a stack overflow without lazyness.</p><pre class="language-ocaml"><code>let rec lazy_model n =
  let prev = lazy_model (n - 1) in
  let next = lazy_model (n + 1) in
  let cur = Tint n in
  Tlazy (lazy (Tobj [ (&quot;cur&quot;, cur) ; (&quot;prev&quot;, prev) ; (&quot;next&quot;, next) ]) )</code></pre><p><a href="#type-tvalue.Tvolatile"><code>tvalue.Tvolatile</code></a> You can use volatile values for variables that can not be defined at model's definition time or if it is subject to changes over time on ocaml's side</p><h3 id="function-calls"><a href="#function-calls" class="anchor"></a>Function calls</h3><p>Built-in functions (aka filters) expect the <b>TARGET</b> value to be the <b>LAST</b> argument, in order to be usable with the pipe notation. You are encouraged to do the same while defining your own functions.</p><p><code>{{ x | foo (10,20) }}</code> is equivalent too <code>{{ foo (10,20,x) }}</code>.</p><p>Functions support partial application. e.g. <code>{{ list | map (foo (10,20)) }}</code></p><p>There is two kind of arguments: <a href="#type-args">unnamed arguments</a> and <a href="#type-kwargs">keyword arguments</a>.</p><p>When defining a <b>keyword argument</b>, <b>label can't be omitted</b>.</p><p>You <b>can't</b> use <code>slice(4, [1,2,3,4,5], 0)</code>, because you need to explicitly bind <code>0</code> with the <code>fill_with</code> label.</p><p>A correct usage of the <code>slice</code> function would be <code>slice(4, [1,2,3,4,5], fill_with=0)</code>.</p><p>Note that kwargs may be defined at any place: <code>slice(4, fill_with=0, [1,2,3,4,5])</code>.</p></div></body></html>
